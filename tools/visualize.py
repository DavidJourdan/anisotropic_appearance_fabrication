import argparse
from enum import Enum

import numpy as np
import pyvista as pv
from svgpathtools import svg2paths

import cglib.array
import cglib.backend
import cglib.cycle
import cglib.fdm_aa
import cglib.grid
import cglib.point_data
import cglib.polyline
import cglib.scalar


class DataToSee(Enum):
    """
    Enumeration of the data that can be visualized.

    Attributes
    ----------
    SCALAR:
        The scalar field resulting from the evaluation of the aligned sine
        field, i.e., the grid of sine waves.
    TUBE:
        The cycle with varying width represented as a tube.
    SDF:
        The signed distance field of the 2D shape.
    """
    SCALAR = 'scalar'
    TUBE = 'tube'
    SDF = 'sdf'


if __name__ == "__main__":

    parser = argparse.ArgumentParser(
        description='Tool to visualize the cycle with varying radius, or the scalar field generated by fill_2d_shape.py, or the signed distance field. Input: The JSON file used by fill_2d_shape.py.'
    )
    parser.add_argument(
        "input_filename", help="The JSON file used by fill_2d_shape.py")
    parser.add_argument(
        "datatosee", help="The data to visualize. Either `tube` to see the cycle, or `scalar` to see the scalar field which is the evaluation of the grid of aligned sines, or `sdf` to see the signed distance field of the 2D shape.")
    args = parser.parse_args()

    input_param_filename = args.input_filename

    parameters = cglib.fdm_aa.Parameters()
    parameters.load(input_param_filename)

    # Load svg paths
    _, _, svg_attributes = svg2paths(
        parameters.svg_path, return_svg_attributes=True)

    # The domain size is determined by the SVG width and height
    svg_width = float(svg_attributes['width'][:-2])
    svg_height = float(svg_attributes['height'][:-2])
    domain_size = np.array([svg_width, svg_height, svg_width*0.01])

    nozzle_width_derived_params = \
        cglib.fdm_aa.compute_nozzle_width_derived_parameters(
            parameters.nozzle_width,
            parameters.layer_height_rt_nozzle_width)

    # Get the grid
    grid_sines_aligned = cglib.point_data.grid_load(
        parameters.grid_sines_aligned_filename)
    grid_sines_aligned_grid = grid_sines_aligned.grid

    # Get the shape contour
    boundary_polydata = pv.read(parameters.boundary_polydata_filename)

    if args.datatosee != DataToSee.SDF.value:

        # Get the cycle polyline
        cycle_polyline = cglib.polyline.load(parameters.cycle_polyline_filename)

        # Get the number of cycles
        cycles = cglib.cycle.load(parameters.cycles_filename)
        print(f"Cycle count before stitching: {cycles.cycle_count}")

        # Convert the cycle to pyvista polyline
        cycle_polyline_pv = pv.PolyData()
        cycle_polyline_2dpoint: np.ndarray = cycle_polyline.point[0]
        layer_height = cycle_polyline.data[0, 1]
        layer_height_array = np.full(
            (cycle_polyline_2dpoint.shape[0], 1),
            layer_height)
        cycle_polyline_pv.points = np.concatenate(
            (cycle_polyline_2dpoint, layer_height_array),
            axis=1)

        cycle_polyline_pv_cells = np.arange(
            -1, cycle_polyline_pv.n_points, dtype=np.int_)
        cycle_polyline_pv_cells[0] = cycle_polyline_pv.n_points

        cycle_polyline_pv.lines = cycle_polyline_pv_cells
        cycle_polyline_pv.point_data["point_id"] = np.arange(
            cycle_polyline_pv.n_points)
        cycle_polyline_pv.point_data["radius"] = cycle_polyline.point_data[0]
        cycle_polyline_tube = cycle_polyline_pv.tube(
            radius=nozzle_width_derived_params.min_radius, radius_factor=nozzle_width_derived_params.max_radius/nozzle_width_derived_params.min_radius, scalars='radius')

    off_screen = False
    plotter = pv.Plotter(shape=(1, 1), off_screen=off_screen)

    if args.datatosee == DataToSee.SCALAR.value:
        scalar_field = np.load(parameters.scalar_field_filename)

        scalar_field_pv = pv.ImageData()
        scalar_field_pv.dimensions = np.concatenate(
            (np.array(scalar_field.shape), np.array([0]))) + 1
        # The bottom left corner of the data set
        scalar_field_pv.origin = np.concatenate(
            (np.array(grid_sines_aligned_grid.origin), np.array([0.])))
        # These are the cell sizes along each axis
        scalar_field_pv.spacing = np.full(
            (3,), grid_sines_aligned_grid.cell_sides_length)
        # Add the data values to the cell data
        scalar_field_pv.cell_data["values"] = scalar_field.flatten()
        plotter.add_mesh(scalar_field_pv, show_edges=False)

    if args.datatosee == DataToSee.TUBE.value:
        plotter.add_mesh(cycle_polyline_tube, scalars='radius',
                         show_scalar_bar=True, opacity=0.75, cmap='viridis')

    if args.datatosee == DataToSee.SDF.value:
        shape_domain_grid = cglib.fdm_aa.discretize_2dshape_domain_with_cells(
            parameters.nozzle_width, domain_size)
        shape_domain_grid_data = cglib.fdm_aa.ShapeDomainGridData()
        parameters.create_SDF_filename(shape_domain_grid)
        shape_domain_grid_data.load(parameters.sdf_filename)

        scalar_field_pv = pv.ImageData()
        scalar_field_pv.dimensions = np.concatenate(
            (np.array(shape_domain_grid_data.grid.cell_ndcount), np.array([0]))) + 1
        # The bottom left corner of the data set
        scalar_field_pv.origin = np.concatenate(
            (np.array(shape_domain_grid_data.grid.origin), np.array([0.])))
        # These are the cell sizes along each axis
        scalar_field_pv.spacing = np.full(
            (3,), shape_domain_grid_data.grid.cell_sides_length)
        # Add the data values to the cell data
        scalar_field_pv.cell_data["values"] = shape_domain_grid_data.ccpj_signed_distance_from_boundary
        plotter.add_mesh(scalar_field_pv, show_edges=False)

    plotter.add_mesh(boundary_polydata, color='fbb4ae',
                     show_scalar_bar=True, show_edges=False, line_width=4)

    plotter.camera_position = 'xy'
    plotter.camera.zoom(1.5)
    plotter.set_background('white')
    plotter.show()
